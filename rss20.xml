<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>inforno</title>
    <link>http://inforno.net/</link>
    <description>information &#43; inferno ... inforno</description>
    <copyright>Yusuke Inuzuka</copyright>
    
    
    <lastBuildDate>10 Dec 15 15:00 UTC</lastBuildDate>
    
    <generator>silkylog</generator>
    
    
    <item>
      <title>Goのインタフェースがパフォーマンスに及ぼす影響 </title>
      <link>http://inforno.net/articles/2015/12/11/go-interface-performance-penalty</link>
      <description>&lt;p&gt;&lt;a class=&#34;reference external&#34; href=&#34;http://qiita.com/advent-calendar/2015/go3&#34;&gt;Go Advent Calendar 2015 その3&lt;/a&gt; 11日目です。その3まであるなんてGo大人気ですね。&lt;/p&gt;
&lt;p&gt;Gopherというのはいろいろな人がいてLLからGoへ、という方も多いかと思います。&lt;/p&gt;
LLではそもそも全てがオブジェクトだったりで話題になりませんが、よりマシンに近く&lt;s&gt;変態的に&lt;/s&gt;速度を重視される方が多いC&#43;&#43;では例えば仮想関数や実行時キャストのコストが議論になります。&lt;p&gt;Goにおいてこういう多態性はインタフェースで表現されます。結論からいうと、 &lt;strong&gt;Goのインタフェースにもそれなりのコストがあります。&lt;/strong&gt; なので極限までパフォーマンスを要求される場合には &lt;strong&gt;例えばインターフェースを使わない&lt;/strong&gt; というも選択肢に入ってくるのではないかと思います。&lt;/p&gt;
&lt;section&gt;
&lt;h2&gt;Go言語におけるインタフェースの内部表現&lt;/h2&gt;
&lt;p&gt;さて、Goはブートストラップ化(言語処理系をその言語自身で実装する)を進めており、1.5ではGoのコンパイラ、ランタイムはほぼほぼGoで実装されています。ということはインターフェースもGoで実装されているはずですね。&lt;/p&gt;
&lt;p&gt;Goのインタフェースは２個のポインタを持った &lt;code&gt;struct&lt;/code&gt; です。例えば、 &lt;code&gt;reflect/value.go&lt;/code&gt; では以下のようなコードがあります。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;reference external&#34; href=&#34;https://raw.githubusercontent.com/golang/go/master/src/reflect/value.go&#34;&gt;reflect/value.go&lt;/a&gt; :&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-go&#34;&gt; // emptyInterface is the header for an interface{} value.
 type emptyInterface struct {
     typ  *rtype
     word unsafe.Pointer
 }

 // nonEmptyInterface is the header for a interface value with methods.
 type nonEmptyInterface struct {
     // see ../runtime/iface.go:/Itab
     itab *struct {
         ityp   *rtype // static interface type
         typ    *rtype // dynamic concrete type
         link   unsafe.Pointer
         bad    int32
         unused int32
         fun    [100000]unsafe.Pointer // method table
     }
     word unsafe.Pointer
 }&lt;/pre&gt;&lt;p&gt;コメントに書かれているように実態は &lt;code&gt;runtime/iface.go&lt;/code&gt; ですがこちらのほうが簡略化されていてわかりやすいでしょう。1個目のポインタは 「空のインタフェース( &lt;code&gt;iterface{}&lt;/code&gt; )」(これを &lt;code&gt;eface&lt;/code&gt; という)の場合、型情報、そうでない場合(これを &lt;code&gt;iface&lt;/code&gt; という)の場合 &lt;code&gt;itab&lt;/code&gt; と呼ばれるC&#43;&#43;における仮想テーブルのようなものです。2個目に値が格納されます。2個目はどちらもポインタであることに注意してください。&lt;/p&gt;
&lt;/section&gt;
&lt;section&gt;
&lt;h2&gt;インターフェース経由のメソッド呼び出し&lt;/h2&gt;
&lt;p&gt;ここで、インターフェースを使用するとどの程度パフォーマンスペナルティがあるのか、様々なケースで見てみます。&lt;/p&gt;
&lt;p&gt;まずは、直接メソッドを呼び出すのと、インタフェース経由で呼び出す場合の違いを見てみましょう。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-go&#34;&gt; type MyError struct{}
 func (e *MyError) Error() string { return &#34;error&#34; }

 func BenchmarkNoInterface(b *testing.B) {
     for i := 0; i &amp;lt; b.N; i&#43;&#43; {
         err := &amp;amp;MyError{}
         err.Error()
     }
 }

 func BenchmarkInterface(b *testing.B) {
     for i := 0; i &amp;lt; b.N; i&#43;&#43; {
         var err error = &amp;amp;MyError{}
         err.Error()
     }
 }&lt;/pre&gt;&lt;p&gt;結果は以下のようになります。10倍程度遅くなります。単位が単位なので微々たる違いですが極限までパフォーマンスを追求したい場合は考慮しておいたほうがいいかもしれませんね。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-bash&#34;&gt; BenchmarkNoInterface    2000000000               0.73 ns/op
 BenchmarkInterface      200000000                9.56 ns/op&lt;/pre&gt;&lt;p&gt;しかし実はこの中には &lt;code&gt;*MyError&lt;/code&gt; を &lt;code&gt;error&lt;/code&gt; インタフェースに変換するコストも含まれていて、そのコストを除くと5倍くらいの遅さです。次はそのインタフェースへの変換コストを詳しく見ていこうと思います。&lt;/p&gt;
&lt;/section&gt;
&lt;section&gt;
&lt;h2&gt;インターフェースへの変換コスト(非ポインタ型)&lt;/h2&gt;
&lt;p&gt;Goにおけるインタフェースの変換時はC&#43;&#43;におけるキャストよりも複雑なことが発生します。&lt;/p&gt;
&lt;p&gt;Goでは「なんでも」を表すために &lt;code&gt;interface{}&lt;/code&gt; を使いますね。 &lt;code&gt;int&lt;/code&gt; などの組み込み型かつ非ポインタ型を &lt;code&gt;interface{}&lt;/code&gt; として処理するとなにが起こるでしょうか？以下のようにフィボナッチを計算させてみます。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-go&#34;&gt; func IntFibNoInterface(n int) int {
     if n &amp;lt; 2 {
         return n
     }
     return IntFibNoInterface(n-1) &#43; IntFibNoInterface(n-2)
 }

 func IntFibInterface(o interface{}) interface{} {
     n := o.(int)
     if n &amp;lt; 2 {
         return o
     }
     return IntFibInterface(n-1).(int) &#43; IntFibInterface(n-2).(int)
 }

 func BenchmarkNoInterface(b *testing.B) {
     for i := 0; i &amp;lt; b.N; i&#43;&#43; {
         IntFibNoInterface(20)
     }
 }

 func BenchmarkInterface(b *testing.B) {
     for i := 0; i &amp;lt; b.N; i&#43;&#43; {
         IntFibInterface(20)
     }
 }&lt;/pre&gt;&lt;p&gt;結果は以下。40 - 50倍くらいおそくなりますね。これを見ると気軽にインタフェースを使いたくなくなるかもしれません。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-bash&#34;&gt; BenchmarkNoInterface       30000             57938 ns/op               0 B/op          0 allocs/op
 BenchmarkInterface           500           2448250 ns/op          525376 B/op      32836 allocs/op&lt;/pre&gt;&lt;p&gt;はじめに書いたように、インタフェースは &lt;strong&gt;ポインタとして値を保持します&lt;/strong&gt; 。 そのためコード上アロケートしていなくても、内部的に &lt;code&gt;int&lt;/code&gt; をアロケートしそこに値をコピーせねばなりません。&lt;/p&gt;
&lt;p&gt;どのような処理が実行されたか、プロファイルを見てみましょう。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-bash&#34;&gt; 1.46s of 1.46s total (  100%)
 Showing top 20 nodes out of 35 (cum &amp;gt;= 0.01s)
       flat  flat%   sum%        cum   cum%
      0.37s 25.34% 25.34%      0.68s 46.58%  runtime.mallocgc
      0.26s 17.81% 43.15%      1.44s 98.63%  12.IntFibInterface
      0.20s 13.70% 56.85%      0.20s 13.70%  runtime.memmove
      0.16s 10.96% 67.81%      0.16s 10.96%  runtime.mSpan_Sweep.func1
      0.12s  8.22% 76.03%      0.96s 65.75%  runtime.convT2E
      0.11s  7.53% 83.56%      0.31s 21.23%  runtime.typedmemmove
      0.10s  6.85% 90.41%      0.26s 17.81%  runtime.heapBitsSweepSpan
      0.05s  3.42% 93.84%      0.22s 15.07%  runtime.assertE2T
      0.02s  1.37% 95.21%      0.70s 47.95%  runtime.newobject
      0.02s  1.37% 96.58%      0.02s  1.37%  runtime.prefetchnta
      0.01s  0.68% 97.26%      0.01s  0.68%  runtime.(*gcControllerState).findRunnableGCWorker
      0.01s  0.68% 97.95%      0.01s  0.68%  runtime.lock
      0.01s  0.68% 98.63%      0.01s  0.68%  runtime.mSpanList_InsertBack
      0.01s  0.68% 99.32%      0.01s  0.68%  runtime.xadd64
      0.01s  0.68%   100%      0.01s  0.68%  runtime.xchg
          0     0%   100%      1.44s 98.63%  12.BenchmarkInterface
          0     0%   100%      0.01s  0.68%  runtime.GC
          0     0%   100%      0.01s  0.68%  runtime.deductSweepCredit
          0     0%   100%      0.01s  0.68%  runtime.gc
          0     0%   100%      0.01s  0.68%  runtime.gc.func4&lt;/pre&gt;&lt;/section&gt;
&lt;section&gt;
&lt;h2&gt;非ポインタ型のインターフェースへの変換コスト&lt;/h2&gt;
&lt;p&gt;では、ということで自分でアロケーションしてみましょう。 &lt;code&gt;int&lt;/code&gt; ではなく &lt;code&gt;*int&lt;/code&gt; を使ってみます。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-go&#34;&gt; func IntFibNoInterface(n int) int {
     if n &amp;lt; 2 {
         return n
     }
     return IntFibNoInterface(n-1) &#43; IntFibNoInterface(n-2)
 }

 func IntFibPointer(i *int) *int {
     n := *i
     if n &amp;lt; 2 {
         return i
     }
     a1 := new(int)
     *a1 = n - 1
     a2 := new(int)
     *a2 = n - 2
     v1 := IntFibPointer(a1)
     v2 := IntFibPointer(a2)
     ret := new(int)
     *ret = *v1 &#43; *v2
     return ret
 }

 func IntFibInterface(o interface{}) interface{} {
     n := *(o.(*int))
     if n &amp;lt; 2 {
         return o
     }
     a1 := new(int)
     *a1 = n - 1
     a2 := new(int)
     *a2 = n - 2
     v1 := IntFibInterface(a1).(*int)
     v2 := IntFibInterface(a2).(*int)
     ret := new(int)
     *ret = *v1 &#43; *v2
     return ret
 }

 func BenchmarkNoInterface(b *testing.B) {
     for i := 0; i &amp;lt; b.N; i&#43;&#43; {
         IntFibNoInterface(20)
     }
 }

 func BenchmarkPointer(b *testing.B) {
     for i := 0; i &amp;lt; b.N; i&#43;&#43; {
         a := new(int)
         *a = 20
         IntFibPointer(a)
     }
 }

 func BenchmarkInterface(b *testing.B) {
     for i := 0; i &amp;lt; b.N; i&#43;&#43; {
         a := new(int)
         *a = 20
         IntFibInterface(a)
     }
 }&lt;/pre&gt;&lt;p&gt;結果は以下のようになります。20-30倍というところでしょうか。こちらのほうがコードだけ見ると遅そうですが、なんと &lt;code&gt;int&lt;/code&gt; を使った場合より速いのです。そして、インタフェースへの変換コストは少ない、ということがわかります。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-bash&#34;&gt; BenchmarkNoInterface       30000             55558 ns/op               0 B/op          0 allocs/op
 BenchmarkPointer            1000           1297598 ns/op          525376 B/op      32836 allocs/op
 BenchmarkInterface          1000           1357172 ns/op          525376 B/op      32836 allocs/op&lt;/pre&gt;&lt;pre class=&#34;prettyprint lang-bash&#34;&gt; 1.54s of 1.54s total (  100%)
 Showing top 20 nodes out of 37 (cum &amp;gt;= 0.01s)
       flat  flat%   sum%        cum   cum%
      0.75s 48.70% 48.70%      1.24s 80.52%  runtime.mallocgc
      0.22s 14.29% 62.99%      0.22s 14.29%  runtime.mSpan_Sweep.func1
      0.16s 10.39% 73.38%      0.38s 24.68%  runtime.heapBitsSweepSpan
      0.14s  9.09% 82.47%      1.38s 89.61%  runtime.newobject
      0.11s  7.14% 89.61%      1.49s 96.75%  12.IntFibInterface
      0.08s  5.19% 94.81%      0.08s  5.19%  runtime.prefetchnta
      0.02s  1.30% 96.10%      0.02s  1.30%  runtime.heapBitsForObject
      0.01s  0.65% 96.75%      0.01s  0.65%  runtime.(*bucket).mp
      0.01s  0.65% 97.40%      0.01s  0.65%  runtime.atomicload64
      0.01s  0.65% 98.05%      0.41s 26.62%  runtime.mCentral_CacheSpan
      0.01s  0.65% 98.70%      0.03s  1.95%  runtime.scanblock
      0.01s  0.65% 99.35%      0.01s  0.65%  runtime.schedule
      0.01s  0.65%   100%      0.01s  0.65%  runtime.xchg
          0     0%   100%      1.49s 96.75%  12.BenchmarkInterface
          0     0%   100%      0.04s  2.60%  runtime.backgroundgc
          0     0%   100%      0.01s  0.65%  runtime.deductSweepCredit
          0     0%   100%      0.04s  2.60%  runtime.gc
          0     0%   100%      0.02s  1.30%  runtime.gc.func1
          0     0%   100%      0.01s  0.65%  runtime.gc.func3
          0     0%   100%      0.01s  0.65%  runtime.gc.func4&lt;/pre&gt;&lt;/section&gt;
&lt;section&gt;
&lt;h2&gt;非ポインタ型とポインタ型の違いは？&lt;/h2&gt;
&lt;p&gt;プロファイルをみるとわかりますが、 &lt;code&gt;runtime.convT2E&lt;/code&gt; , &lt;code&gt;runtime.assertE2T&lt;/code&gt; が非ポインタ型の場合重荷になっています。ここまで「ポインタ型」「非ポインタ型」という曖昧な表現をしていましたが、正確には
これは &lt;code&gt;isdirectiface&lt;/code&gt; という関数の結果が &lt;code&gt;true&lt;/code&gt; かどうかです。これによりインターフェス変換の処理が変わります。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-go&#34;&gt; // Can this type be stored directly in an interface word?
 // Yes, if the representation is a single pointer.
 func isdirectiface(t *Type) bool {
     switch t.Etype {
     case TPTR32,
         TPTR64,
         TCHAN,
         TMAP,
         TFUNC,
         TUNSAFEPTR:
         return true

         // Array of 1 direct iface type can be direct.
     case TARRAY:
         return t.Bound == 1 &amp;amp;&amp;amp; isdirectiface(t.Type)

         // Struct with 1 field of direct iface type can be direct.
     case TSTRUCT:
         return t.Type != nil &amp;amp;&amp;amp; t.Type.Down == nil &amp;amp;&amp;amp; isdirectiface(t.Type.Type)
     }

     return false
 }&lt;/pre&gt;&lt;p&gt;これが &lt;code&gt;false&lt;/code&gt; になるオブジェクトをインタフェースとして利用する際は注意です。&lt;/p&gt;
&lt;/section&gt;
&lt;section&gt;
&lt;h2&gt;時にはインタフェースを使わない、という選択も&lt;/h2&gt;
&lt;p&gt;以上のことから、特に性能が必要な場合、インタフェースを使わず擬似共用体(Goに共用体はないので)のような実装をしたほうがよい場合が出てきます。フィボナッチの例を &lt;code&gt;struct&lt;/code&gt; で書いてみましょう。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-go&#34;&gt; const (
     TypeInt int = iota
     TypeBool
 )

 type Object struct {
     Type      int
     IntValue  int
     BoolValue bool
 }

 func IntFibNoInterface(n int) int {
     if n &amp;lt; 2 {
         return n
     }
     return IntFibNoInterface(n-1) &#43; IntFibNoInterface(n-2)
 }

 func IntFibStruct(o Object) Object {
     if o.IntValue &amp;lt; 2 {
         return o
     }
     return Object{TypeInt,
         IntFibStruct(Object{TypeInt, o.IntValue - 1, false}).IntValue &#43;
             IntFibStruct(Object{TypeInt, o.IntValue - 2, false}).IntValue,
         false}
 }

 func BenchmarkNoInterface(b *testing.B) {
     for i := 0; i &amp;lt; b.N; i&#43;&#43; {
         IntFibNoInterface(20)
     }
 }

 func BenchmarkStruct(b *testing.B) {
     for i := 0; i &amp;lt; b.N; i&#43;&#43; {
         IntFibStruct(Object{TypeInt, 20, false})
     }
 }&lt;/pre&gt;&lt;p&gt;速度ですが、インタフェースを使うより断然早く、2-3倍程度しか遅くなりません。当たり前ですが、暗黙的なメモリアロケーションも発生しません。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-bash&#34;&gt; BenchmarkNoInterface       30000             58491 ns/op               0 B/op          0 allocs/op
 BenchmarkStruct            10000            139924 ns/op               0 B/op          0 allocs/op&lt;/pre&gt;&lt;p&gt;&lt;code&gt;reflect&lt;/code&gt; を使えば・・・というのもありますが、結局 &lt;code&gt;reflect.ValueOf&lt;/code&gt; の引数が &lt;code&gt;interface{}&lt;/code&gt; なので素直に使うと &lt;code&gt;interface{}&lt;/code&gt; の場合と同様の遅さです。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-go&#34;&gt; func IntFibNoInterface(n int) int {
     if n &amp;lt; 2 {
         return n
     }
     return IntFibNoInterface(n-1) &#43; IntFibNoInterface(n-2)
 }

 func IntFibReflect(r reflect.Value) reflect.Value {
     n := r.Int()
     if n &amp;lt; 2 {
         return r
     }
     return reflect.ValueOf(IntFibReflect(reflect.ValueOf(n-1)).Int() &#43; IntFibReflect(reflect.ValueOf(n-2)).Int())
 }

 func BenchmarkNoInterface(b *testing.B) {
     for i := 0; i &amp;lt; b.N; i&#43;&#43; {
         IntFibNoInterface(20)
     }
 }

 func BenchmarkReflect(b *testing.B) {
     for i := 0; i &amp;lt; b.N; i&#43;&#43; {
         IntFibReflect(reflect.ValueOf(20))
     }
 }&lt;/pre&gt;&lt;pre class=&#34;prettyprint lang-bash&#34;&gt; BenchmarkNoInterface       30000             56238 ns/op               0 B/op          0 allocs/op
 BenchmarkReflect            1000           2271026 ns/op          525376 B/op      32836 allocs/op&lt;/pre&gt;&lt;/section&gt;
&lt;section&gt;
&lt;h2&gt;ちなみにGopherLuaでは&lt;/h2&gt;
&lt;p&gt;拙作のGo言語によるLua実装 &lt;a class=&#34;reference external&#34; href=&#34;https://github.com/yuin/gopher-lua&#34;&gt;GopherLua&lt;/a&gt; では一番おそい、非ポインタ型をインタフェースとして使う実装になっています。なのでGopherLuaはおそらく現在でもGo上で動くスクリプト言語としては最速の部類ですがさらに速くしようと思えばできたのかもなあと思っています(まぁこの例ほど言語実装は単純ではないし、擬似共用体にするにしてもサイズが大きくなるので、速くなるかどうかはやってみないとなんともいえないのですが。あとサイズがおおきくなるのでスタック型のAPIにするよりないでしょうね)。&lt;/p&gt;
&lt;p&gt;これは使い易さや実装のし易さやメモリ効率、そして「Goらしさ」とのトレードオフだと思っています。私は、とにかく使い易いものがほしかったので一番使い易く、そして実装が楽なものを選びました。&lt;/p&gt;
&lt;p&gt;とはいえ、特に数値型をインタフェースに変換する負荷を軽減するために、独自のアロケータを実装しています。これは一定数の &lt;code&gt;float64&lt;/code&gt; をまとめてアロケートすることでインタフェース変換コストを減らしています。かなり強引なのですが興味のある方は &lt;a class=&#34;reference external&#34; href=&#34;https://github.com/yuin/gopher-lua/blob/master/alloc.go&#34;&gt;gopher-lua/alloc.go&lt;/a&gt; をご参照ください。&lt;/p&gt;
&lt;/section&gt;
&lt;section&gt;
&lt;h2&gt;最後に&lt;/h2&gt;
&lt;p&gt;インタフェースはGoで中心的な役割を果たしていますが、時に大幅なパフォーマンス劣化を起こす可能性があります。 特に、非ポインタ型を &lt;code&gt;interface{}&lt;/code&gt; などとして引数に渡す場合が要注意です。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;reference external&#34; href=&#34;http://qiita.com/advent-calendar/2015/go3&#34;&gt;Go Advent Calendar 2015 その3&lt;/a&gt; 12日目は &lt;a class=&#34;reference external&#34; href=&#34;http://qiita.com/Ladicle&#34;&gt;Ladicle&lt;/a&gt; さんです。&lt;/p&gt;
&lt;/section&gt;
</description>
      
      <category>golang</category>
      
      <guid isPermaLink="true">http://inforno.net/articles/2015/12/11/go-interface-performance-penalty</guid>
      <pubDate>10 Dec 15 15:00 UTC</pubDate>
    </item>
    
    <item>
      <title>icebergのLinux対応版 v0.9.7リリース </title>
      <link>http://inforno.net/articles/2015/11/19/iceberg-0-9-7-released</link>
      <description>&lt;p&gt;コマンドラインランチャー &lt;a class=&#34;reference external&#34; href=&#34;http://yuin.github.io/iceberg/&#34;&gt;iceberg&lt;/a&gt; のv0.9.7 をリリースしました。 GitHubの &lt;a class=&#34;reference external&#34; href=&#34;https://github.com/yuin/iceberg/releases&#34;&gt;リリース一覧&lt;/a&gt; よりダウンロードできます。&lt;/p&gt;
&lt;p&gt;今回からLinuxに対応しました。私は普段、ほぼWindowsがホストでVirtualbox上のUbuntuで開発を行っておりそこではLaunchyを使ってお茶をにごして？いたのです。がやはり慣れているicebergを使いたいと思っていたのでがんばって対応してみました。&lt;/p&gt;
&lt;p&gt;Macを使っている人はそもそもAlfredなどを使っているでしょうけど、Windowsだと私と同じかたちの人も多いのではないかと思います。ぜひ使ってみてください。Linuxのコマンドラインランチャーでmigemo対応しているものはなかなか無いのではないでしょうか。&lt;/p&gt;
&lt;p&gt;icebergはQtやGTKではなくfltkというミニマリストなGUIフレームワークなのでGUI以外の機能はほとんどフレームワークにありません。かといって、ここでQtやGTKに依存するのも癪だったのでLinuxではアイコンのルックアップなどを自分で実装したんですが結構しんどかったですね･･･。ただ、あらかじめマルチプラットフォームを視野にいれたつくりにしてあったので、ゴリゴリ書いていくだけで動くのは動いたのでよかったです。&lt;/p&gt;
&lt;p&gt;内部的にはfltkのバージョンもあげました。これでWindows8以降でも互換モードなしで動いたりしないかなあ、と思っているのですが、いかんせん実機をもっていないのでどうにも。次はWindows10にすると思うので結局Windows8系は確認できないまま終わりそうです。&lt;/p&gt;
&lt;p&gt;あと、ここまできたらなんでMacに対応しないんだ、となりそうですが単純に私がMacを持っていないからです。それに、icebergはMacの文化に合わない気がします。ただ、icebergは作者の私が一番の愛用者であるソフトなのでもし私がMacを手に入れることがあったら、対応すると思います。まぁイケてる会社のプログラマーに転職でもしないとMacを使うようなことはないと思いますが。&lt;/p&gt;
&lt;p&gt;なにか問題ありましたらGithubの &lt;a class=&#34;reference external&#34; href=&#34;https://github.com/yuin/iceberg/issues&#34;&gt;Issues&lt;/a&gt; までどうぞ。&lt;/p&gt;
</description>
      
      <category>iceberg</category>
      
      <guid isPermaLink="true">http://inforno.net/articles/2015/11/19/iceberg-0-9-7-released</guid>
      <pubDate>19 Nov 15 11:58 UTC</pubDate>
    </item>
    
    <item>
      <title>GopherLuaを設定ファイルで使うライブラリを書きました </title>
      <link>http://inforno.net/articles/2015/03/23/gluamapper-released</link>
      <description>&lt;p&gt;&lt;a class=&#34;reference external&#34; href=&#34;https://github.com/yuin/gopher-lua&#34;&gt;GopherLua&lt;/a&gt; で設定ファイルを書くためのライブラリを書きました。設定ファイル以外にも使えますけど。&lt;/p&gt;
&lt;div data-theme=&#34;default&#34; data-height=&#34;150&#34; data-width=&#34;400&#34; data-github=&#34;yuin/gluamapper&#34; class=&#34;github-card&#34;&gt;&lt;/div&gt;&lt;script src=&#34;http://lab.lepture.com/github-cards/widget.js&#34;&gt;&lt;/script&gt;&lt;p&gt;モノとしてはGopherLuaのテーブルをGoの構造体にマップしてくれます。といっても、内部動作的にはHashicorpの &lt;a class=&#34;reference external&#34; href=&#34;https://github.com/mitchellh/mapstructure&#34;&gt;mapstructure&lt;/a&gt; を使っているだけだったりします。一度GopherLuaのテーブルを &lt;code&gt;map[string]interface{}&lt;/code&gt; に変換してあげて、あとはmapstructureにおまかせ。&lt;/p&gt;
&lt;p&gt;ただ、一般的なLuaの命名規則とGoの命名規則が違うので名前を変換する関数が指定できます。デフォルトでは &lt;code&gt;snake_case&lt;/code&gt; を &lt;code&gt;CamelCase&lt;/code&gt; に変換します。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-go&#34;&gt; type Role struct {
     Name string
 }

 type Person struct {
     Name      string
     Age       int
     WorkPlace string
     Role      []*Role
 }

 L := lua.NewState()
 if err := L.DoString(`
 person = {
   name = &#34;Michel&#34;,
   age  = &#34;31&#34;, -- weakly input
   work_place = &#34;San Jose&#34;,
   role = {
     {
       name = &#34;Administrator&#34;
     },
     {
       name = &#34;Operator&#34;
     }
   }
 }
 `); err != nil {
     panic(err)
 }
 var person Person
 if err := gluamapper.Map(L.GetGlobal(&#34;person&#34;).(*lua.LTable), &amp;amp;person); err != nil {
     panic(err)
 }
 fmt.Printf(&#34;%s %d&#34;, person.Name, person.Age)&lt;/pre&gt;&lt;p&gt;のように非常に簡単にLuaを設定ファイルとして使うことができます。Luaは可読性が高く、JSONと異なりコメントが書けて、YAMLよりも簡単に値を変数化できるので設定ファイルにすると便利です(なんでも出来てしまう、というのがネックと言えばネックですが)。&lt;/p&gt;
</description>
      
      <category>gopherlua</category>
      
      <category>golang</category>
      
      <category>lua</category>
      
      <guid isPermaLink="true">http://inforno.net/articles/2015/03/23/gluamapper-released</guid>
      <pubDate>23 Mar 15 12:12 UTC</pubDate>
    </item>
    
    <item>
      <title>GopherLuaでchannelを扱えるようにした </title>
      <link>http://inforno.net/articles/2015/02/24/channel-support-in-gopher-lua</link>
      <description>&lt;p&gt;先日公開した &lt;a class=&#34;reference external&#34; href=&#34;https://github.com/yuin/gopher-lua&#34;&gt;GopherLua&lt;/a&gt; ですが。&lt;/p&gt;
&lt;p&gt;GopherLuaはLuaなので、ホスト言語との親和性を重視しております。GolangなのにGoroutine関係のサポートがないとだめでしょ！ということで、とりあえずですが、channelを扱えるようにしました。&lt;/p&gt;
&lt;p&gt;これもまたReadmeに書いてありますが、以下のように使います。
selectも使えますし、GolangとLuaの間で縦横無尽にメッセージ通信できます。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-go&#34;&gt; func receiver(ch, quit chan lua.LValue) {
     L := lua.NewState()
     defer L.Close()
     L.SetGlobal(&#34;ch&#34;, lua.LChannel(ch))
     L.SetGlobal(&#34;quit&#34;, lua.LChannel(quit))
     if err := L.DoString(`
     local exit = false
     while not exit do
       channel.select(
         {&#34;|&amp;lt;-&#34;, ch, function(ok, v)
           if not ok then
             print(&#34;channel closed&#34;)
             exit = true
           else
             print(&#34;received:&#34;, v)
           end
         end},
         {&#34;|&amp;lt;-&#34;, quit, function(ok, v)
             print(&#34;quit&#34;)
             exit = true
         end}
       )
     end
   `); err != nil {
         panic(err)
     }
 }

 func sender(ch, quit chan lua.LValue) {
     L := lua.NewState()
     defer L.Close()
     L.SetGlobal(&#34;ch&#34;, lua.LChannel(ch))
     L.SetGlobal(&#34;quit&#34;, lua.LChannel(quit))
     if err := L.DoString(`
     ch:send(&#34;1&#34;)
     ch:send(&#34;2&#34;)
   `); err != nil {
         panic(err)
     }
     ch &amp;lt;- lua.LString(&#34;3&#34;)
     quit &amp;lt;- lua.LTrue
 }

 func main() {
     ch := make(chan lua.LValue)
     quit := make(chan lua.LValue)
     go receiver(ch, quit)
     go sender(ch, quit)
     time.Sleep(3 * time.Second)
 }&lt;/pre&gt;&lt;p&gt;こんな感じですね。Luaと同じくState自体はスレッドセーフではないので、goroutineごとにStateをもってChannelで通信します。&lt;/p&gt;
&lt;section&gt;
&lt;h2&gt;実装について&lt;/h2&gt;
&lt;p&gt;迷ったんですが、channelは &lt;strong&gt;基本型&lt;/strong&gt; として実装しています。 ユーザーデータ型でもよかったんですが、channelはGolangの特徴の一つですし、基本型にしたほうが親和性がよいので。&lt;/p&gt;
&lt;p&gt;あと、内部的にはリフレクションなのでそんなに性能はよくないかもしれません。&lt;/p&gt;
&lt;/section&gt;
&lt;section&gt;
&lt;h2&gt;よければ使ってみてください&lt;/h2&gt;
&lt;p&gt;実装してみたものの、正直私は職業プログラマでなく趣味プログラマなのであんまり使うシーンがないです。なんかいい使いどころがあれば使ってみてください。&lt;/p&gt;
&lt;/section&gt;
</description>
      
      <category>golang</category>
      
      <category>gopherlua</category>
      
      <category>lua</category>
      
      <guid isPermaLink="true">http://inforno.net/articles/2015/02/24/channel-support-in-gopher-lua</guid>
      <pubDate>24 Feb 15 11:00 UTC</pubDate>
    </item>
    
    <item>
      <title>LuaのGo言語実装を公開しました </title>
      <link>http://inforno.net/articles/2015/02/15/gopher-lua-released</link>
      <description>&lt;p&gt;LuaをGo言語のみで実装した &lt;a class=&#34;reference external&#34; href=&#34;https://github.com/yuin/gopher-lua&#34;&gt;GopherLua&lt;/a&gt; を公開しました。&lt;/p&gt;
&lt;p&gt;詳しくはGithubのREADMEを見ていただくとして、特徴としては以下になります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class=&#34;first docutils&#34;&gt;
&lt;dt&gt;Lua5.1ベース&lt;/dt&gt;
&lt;dd&gt;&lt;ul class=&#34;first last simple&#34;&gt;
&lt;li&gt;5.1の機能はほぼ実装済み&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class=&#34;first&#34;&gt;Compiler, VMともに完全にGo言語のみで実装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class=&#34;first&#34;&gt;引数の受け渡し以外でのスタック操作が不要で使いやすいAPI&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;section&gt;
&lt;h2&gt;なぜ作ろうと思ったか&lt;/h2&gt;
&lt;p&gt;もともとC言語でものを作るときにはLuaを設定ファイルの代わりとして取り入れていました。Goではあまり拡張言語実装がないので、jsonだったりiniだったりを設定ファイルとして使っていましたが、やっぱり微妙にめんどくさい。変数くらい欲しいなあ･･･とか。&lt;/p&gt;
&lt;p&gt;結局、固い言語だけでモノを作るのは難しく、やわらかさが必要になるポイントがあります。そういうところはまず、「設定ファイル」として外だしされます。そしてその設定ファイルがどんどん肥大化したり複雑化したりして･･･(XML地獄とか)。Cに対するLua、PythonやRuby、Javaに対するGroovyなど「固い言語」＋「拡張言語」は自分的に一番しっくりくる構成です。それをGoで実現するために実装してみました。&lt;/p&gt;
&lt;p&gt;もうひとつは単純にLuaに興味があったこと。正確にはLuaというよりレジスタ型VMに。スタック型VMは実装したことがあるのですが、レジスタ型で実装してみたかったのです。&lt;/p&gt;
&lt;p&gt;最後に、Go言語で処理系を実装してみたかったこと。実行ファイルが吐けるし、速度はそれなりに速いし、Go自体がGCを持っているのでかなり処理系作るのが楽だと思われるのでどんなものかな、と。&lt;/p&gt;
&lt;/section&gt;
&lt;section&gt;
&lt;h2&gt;簡単な使い方&lt;/h2&gt;
&lt;p&gt;こうして&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-go&#34;&gt;import (
    &#34;github.com/yuin/gopher-lua&#34;
)&lt;/pre&gt;&lt;p&gt;こんな感じですね。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-go&#34;&gt;L := lua.NewState()
defer L.Close()
if err := L.DoString(`print(&#34;hello&#34;)`); err != nil {
    panic(err)
}&lt;/pre&gt;&lt;p&gt;Go関数をLuaで呼ぶ場合は以下のような感じ。LuaとGoの間の引数と戻り値の受け渡しのみにスタックを使います。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-go&#34;&gt;func Double(L lua.LState) int {
    lv := L.ToInt(1)             // get argument
    L.Push(lua.LNumber(lv * 2))  // push result
    return 1                     // number of results
}

func main() {
    L := lua.NewState()
    defer L.Close()
    L.SetGlobal(&#34;double&#34;, L.NewFunction(Double)) // Original lua_setglobal uses stack...
}&lt;/pre&gt;&lt;p&gt;あとは &lt;a class=&#34;reference external&#34; href=&#34;https://github.com/yuin/gopher-lua&#34;&gt;README&lt;/a&gt; をみていただければ大体分かるかと思います。&lt;/p&gt;
&lt;/section&gt;
&lt;section&gt;
&lt;h2&gt;実装について&lt;/h2&gt;
&lt;section&gt;
&lt;h3&gt;全般の話&lt;/h3&gt;
&lt;p&gt;まず、そんなにLua自体のコードは読んでません(おい)。Luaは1パスでコード生成までできる文法で本家はそういう実装ですが、GopherLuaでは&lt;/p&gt;
&lt;ol class=&#34;arabic simple&#34;&gt;
&lt;li&gt;トークナイズ(Lexer, 手書き)&lt;/li&gt;
&lt;li&gt;パース(go-yacc)&lt;/li&gt;
&lt;li&gt;コード生成&lt;/li&gt;
&lt;li&gt;最適化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;まったく違うパス構成なので実装は完全に独自実装です。またyaccなのでユーザが文法を簡単に変えられます。&lt;/p&gt;
&lt;p&gt;現状最適化はほとんどやっていません。複数JMPをまとめるくらい。&lt;/p&gt;
&lt;p&gt;あと、やっぱ三項演算子欲しい･･･。&lt;/p&gt;
&lt;/section&gt;
&lt;section&gt;
&lt;h3&gt;データモデルの話&lt;/h3&gt;
&lt;p&gt;こういう言語を実装する場合はいわゆる共用体のような、1つの型で複数の型を判別できるものが必要となります。Cでは共用体やポインタの下位ビットを使いますが、Goでは以下の選択肢があります。&lt;/p&gt;
&lt;ul class=&#34;simple&#34;&gt;
&lt;li&gt;&lt;code&gt;reflect.Value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;interface&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unsafe.Pointer&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GopherLuaでは &lt;code&gt;interface&lt;/code&gt; を使っています。 &lt;code&gt;interface&lt;/code&gt; は&lt;/p&gt;
&lt;ul class=&#34;simple&#34;&gt;
&lt;li&gt;Go側のAPIを考えたとき一番分かりやすい&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;という利点がある一方&lt;/p&gt;
&lt;ul class=&#34;simple&#34;&gt;
&lt;li&gt;ネイティブ型をラップした &lt;code&gt;interface&lt;/code&gt; の場合、 &lt;code&gt;interface&lt;/code&gt; への変換が発生して速度低下を招く&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;という欠点があります。そこで簡単なベンチマークをしたのですが&lt;/p&gt;
&lt;ul class=&#34;simple&#34;&gt;
&lt;li&gt;単純な例(フィボナッチ計算)では確かに &lt;code&gt;reflect.Value&lt;/code&gt; などが速い。&lt;/li&gt;
&lt;li&gt;一方、複雑な例になればそれほど差が無いように見えた&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ため &lt;code&gt;interface&lt;/code&gt; を採用しました。ただ、プロファイルをとるとかなりの部分が &lt;code&gt;interface&lt;/code&gt; への変換に取られているので、ここが(Goが進化して)速くなればGopherLuaも速くなると思います。&lt;/p&gt;
&lt;/section&gt;
&lt;section&gt;
&lt;h3&gt;速度の話&lt;/h3&gt;
&lt;p&gt;それほどパフォーマンスチューニングはしていませんが、フィボナッチではperlと同じくらいの性能は出ているようです。メモリ確保はそもそも気をつけて減らしているので後は&lt;/p&gt;
&lt;ul class=&#34;simple&#34;&gt;
&lt;li&gt;関数をベタ書きする&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;くらいかなあ。Goは短い関数をinline化してくれますが、そのinline化はそんなに賢くないのでやっぱりダメですね。ためしにVMの関数コール部分などをベタ書きすると1.2倍くらいの速度になりました。今のところそこまで速度を求めていないので元に戻しましたけど。&lt;/p&gt;
&lt;p&gt;やっぱマクロ欲しいなあ･･･&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section&gt;
&lt;h2&gt;とりあえず、使えるはずです&lt;/h2&gt;
&lt;p&gt;Lua5.1のテストは主要なものは通っているので使えるものになっているはずです。設定ファイルのかわりに使うもよし、プラグインの仕組みに使うのもよし。今後はGopherLuaのTableをGoのstructにマッピングするような( &lt;code&gt;json&lt;/code&gt; や &lt;code&gt;xml&lt;/code&gt; パッケージみたいな)ライブラリとか作りたいなと思っていたりします。&lt;/p&gt;
&lt;/section&gt;
</description>
      
      <category>golang</category>
      
      <category>lua</category>
      
      <category>gopherlua</category>
      
      <guid isPermaLink="true">http://inforno.net/articles/2015/02/15/gopher-lua-released</guid>
      <pubDate>15 Feb 15 13:43 UTC</pubDate>
    </item>
    
  </channel>
</rss>
