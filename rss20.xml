<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>inforno</title>
    <link>http://inforno.net/</link>
    <description>information &#43; inferno ... inforno</description>
    <copyright>Yusuke Inuzuka</copyright>
    
    
    <lastBuildDate>13 Jul 16 15:23 UTC</lastBuildDate>
    
    <generator>silkylog</generator>
    
    
    <item>
      <title>Goで文字コードを手軽に変換するライブラリ作った </title>
      <link>http://inforno.net/articles/2016/07/14/go-charsetutil</link>
      <description>&lt;p&gt;日本人である以上、いくらUTF-8が主権を得てきたといっても文字コード変換というカルマからは逃れられません。Pure Goでの文字コード変換はLLに比べるといろいろめんどくさい。&lt;/p&gt;
&lt;p&gt;それに、そのままだと任意の文字コードを指定させるのが難しい。特定の文字コード決め打ちならいいんですけど、全世界の利用者に向けて任意の文字コード設定できるようにする場合とかはさらにめんどくさいし、かといって &lt;code&gt;iconv&lt;/code&gt; に依存するのも嫌なのライブラリにしました。&lt;/p&gt;
&lt;div data-theme=&#34;default&#34; data-height=&#34;150&#34; data-width=&#34;400&#34; data-github=&#34;yuin/charsetutil&#34; class=&#34;github-card&#34;&gt;&lt;/div&gt;&lt;script src=&#34;http://lab.lepture.com/github-cards/widget.js&#34;&gt;&lt;/script&gt;&lt;p&gt;以下のような感じで簡単に文字コードを変換できます。Pythonと同じで &lt;code&gt;encode&lt;/code&gt; がUTF-8からUTF-8以外へ、 &lt;code&gt;decode&lt;/code&gt; がUTF-8以外からUTF-8へ、です。内部では &lt;code&gt;golang.org/x/net/html/charset&lt;/code&gt; を使っているので文字コードの指定もそれに習います。(WHATWGで定義されている名前になります) 。なので &lt;code&gt;cp932&lt;/code&gt; などではなく &lt;code&gt;&lt;span class=&#34;pre&#34;&gt;Windows-31J&lt;/span&gt;&lt;/code&gt; です。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-go&#34;&gt; b, err = EncodeString(&#34;こんにちわ&#34;, &#34;Windows-31J&#34;)
 b, err = Encode(&#34;こんにちわ&#34;, &#34;Windows-31J&#34;)
 b, err = EncodeBytes([]byte(&#34;こんにちわ&#34;), &#34;Windows-31J&#34;)
 b, err = EncodeReader(strings.NewReader(&#34;こんにちわ&#34;), &#34;Windows-31J&#34;)
 b = MustEncodeString(&#34;こんにちわ&#34;, &#34;Windows-31J&#34;)
 b = MustEncode(&#34;こんにちわ&#34;, &#34;Windows-31J&#34;)
 b = MustEncodeBytes([]byte(&#34;こんにちわ&#34;), &#34;Windows-31J&#34;)
 b = MustEncodeReader(strings.NewReader(&#34;こんにちわ&#34;), &#34;Windows-31J&#34;)

 s, err = DecodeString(string(source), &#34;Windows-31J&#34;)
 s, err = Decode(source, &#34;Windows-31J&#34;)
 s, err = DecodeBytes(source, &#34;Windows-31J&#34;)
 s, err = DecodeReader(bytes.NewReader(source), &#34;Windows-31J&#34;)
 s = MustDecodeString(string(source), &#34;Windows-31J&#34;)
 s = MustDecode(source, &#34;Windows-31J&#34;)
 s = MustDecodeBytes(source, &#34;Windows-31J&#34;)
 s = MustDecodeReader(bytes.NewReader(source), &#34;Windows-31J&#34;)&lt;/pre&gt;
</description>
      
      <category>golang</category>
      
      <guid isPermaLink="true">http://inforno.net/articles/2016/07/14/go-charsetutil</guid>
      <pubDate>13 Jul 16 15:23 UTC</pubDate>
    </item>
    
    <item>
      <title>30歳の一年だった。今後について考える。 </title>
      <link>http://inforno.net/articles/2015/12/30/30-years-old-this-year</link>
      <description>&lt;p&gt;もう2015年も終わろうとしています。今31歳ですが私は誕生日が後半なのでこの1年はほぼ30歳として過ごしたことになります。&lt;/p&gt;
&lt;section&gt;
&lt;h2&gt;GopherLua&lt;/h2&gt;
&lt;p&gt;さて、今年は2月に公開した &lt;a class=&#34;reference external&#34; href=&#34;https://github.com/yuin/gopher-lua&#34;&gt;GopherLua&lt;/a&gt; がGithubで1000スター以上もいただき、バンバンIssueやPRが来て新しい体験ができた年でした。&lt;/p&gt;
&lt;p&gt;自分としてはGoは現状速い言語を書くには向いていないし、これは設定ファイルの拡張用、くらいに思っていたのですが意外とサーバサイドに使おうという人がいて驚きましたね。それでもやはり圧倒的にコマンドラインツールの拡張用が多くてシングルバイナリ＋拡張言語がマッチする分野だと思います。&lt;/p&gt;
&lt;p&gt;私はあくまで趣味プログラマなのでこういった機会はOSS活動をしていなければできない経験だったのでとても有益でしたね。英語にとても苦手意識があるのですが、案外適当な英語で通じるものです。&lt;/p&gt;
&lt;/section&gt;
&lt;section&gt;
&lt;h2&gt;なんで趣味でOSSを書いているか&lt;/h2&gt;
&lt;p&gt;なんで趣味でOSSを書いているか…まぁ好きだからですよね。とにかくプログラミングが好きです。&lt;/p&gt;
&lt;p&gt;あとは…どこかに「自分はまだ最低これくらい書ける」というのを確認したいという思いがあるのだと思います。そしてその裏には「やっぱり仕事でコード書きたいなあ」という思いがあるのでしょう。&lt;/p&gt;
&lt;p&gt;この業界は実務経験がすべてですから、もはや実務から離れて久しい私がWEBやモバイル業界に行くことはないでしょうけど、万が一の時に自分の技術力を示す手段としてGithubという場を借りているのかな、と。&lt;/p&gt;
&lt;p&gt;意外と？成果物経由で仕事しませんかというメールをもらえたりとGithubは見られてるんだな、と思いましたね。&lt;/p&gt;
&lt;/section&gt;
&lt;section&gt;
&lt;h2&gt;今後は…&lt;/h2&gt;
&lt;p&gt;転職は35が限界、などという話もありますし今後をどうするか考える時期ですね。正直なところ今の勤め先が定年まで現状維持できる気がまったくしないので&lt;/p&gt;
&lt;ol class=&#34;arabic simple&#34;&gt;
&lt;li&gt;もっと安定している職業へ転職する&lt;/li&gt;
&lt;li&gt;いっそWEB、モバイル業界にチャレンジする&lt;/li&gt;
&lt;li&gt;(深く考えず今の勤め先で頑張る)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;くらいでしょうか。安定している…というと公務員系ですかね。&lt;/p&gt;
&lt;p&gt;いざという時に支えてくれる人がいればリスクを取りやすいのでしょうが、あいにく実家は離婚の上極貧、親戚づきあいなし、兄弟なし、独身(そして結婚も子供も予定なし)とある意味頼れるのは自分と会社だけ、という人間です。&lt;/p&gt;
&lt;p&gt;さらに健康上の理由で海外は絶対行きたくない、となると1しかない気がしてきています。&lt;/p&gt;
&lt;p&gt;その場合は、もうOSSでコード書いてもしかたないかなあ、とかこのブログも消そうかなあ、とか思うところはあります。&lt;/p&gt;
&lt;p&gt;実際には惰性で3.でしょうが(まぁ20年くらいはつぶれないし待遇もそこまで落ちないでしょ…)。&lt;/p&gt;
&lt;/section&gt;
&lt;section&gt;
&lt;h2&gt;2016年&lt;/h2&gt;
&lt;p&gt;とはいえ、2016年もなにかまとまったものが書ければな…とは思っているんです。やっぱり独自言語書きたいですね、普通にCで。 Goで実用的なものもなにか書きたいんですけど、ほんと趣味レベルではなかなかいいモノが思いつきません。いやー、実践でGo書いてみたいので副業できるなら喜んでGoで何か書ける仕事探すんですがねえ…。&lt;/p&gt;
&lt;/section&gt;
</description>
      
      <category>life</category>
      
      <guid isPermaLink="true">http://inforno.net/articles/2015/12/30/30-years-old-this-year</guid>
      <pubDate>30 Dec 15 08:44 UTC</pubDate>
    </item>
    
    <item>
      <title>Goのインタフェースがパフォーマンスに及ぼす影響 </title>
      <link>http://inforno.net/articles/2015/12/11/go-interface-performance-penalty</link>
      <description>&lt;p&gt;&lt;a class=&#34;reference external&#34; href=&#34;http://qiita.com/advent-calendar/2015/go3&#34;&gt;Go Advent Calendar 2015 その3&lt;/a&gt; 11日目です。その3まであるなんてGo大人気ですね。&lt;/p&gt;
&lt;p&gt;Gopherというのはいろいろな人がいてLLからGoへ、という方も多いかと思います。&lt;/p&gt;
LLではそもそも全てがオブジェクトだったりで話題になりませんが、よりマシンに近く&lt;s&gt;変態的に&lt;/s&gt;速度を重視される方が多いC&#43;&#43;では例えば仮想関数や実行時キャストのコストが議論になります。&lt;p&gt;Goにおいてこういう多態性はインタフェースで表現されます。結論からいうと、 &lt;strong&gt;Goのインタフェースにもそれなりのコストがあります。&lt;/strong&gt; なので極限までパフォーマンスを要求される場合には &lt;strong&gt;例えばインターフェースを使わない&lt;/strong&gt; というも選択肢に入ってくるのではないかと思います。&lt;/p&gt;
&lt;section&gt;
&lt;h2&gt;Go言語におけるインタフェースの内部表現&lt;/h2&gt;
&lt;p&gt;さて、Goはブートストラップ化(言語処理系をその言語自身で実装する)を進めており、1.5ではGoのコンパイラ、ランタイムはほぼほぼGoで実装されています。ということはインターフェースもGoで実装されているはずですね。&lt;/p&gt;
&lt;p&gt;Goのインタフェースは２個のポインタを持った &lt;code&gt;struct&lt;/code&gt; です。例えば、 &lt;code&gt;reflect/value.go&lt;/code&gt; では以下のようなコードがあります。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;reference external&#34; href=&#34;https://raw.githubusercontent.com/golang/go/master/src/reflect/value.go&#34;&gt;reflect/value.go&lt;/a&gt; :&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-go&#34;&gt; // emptyInterface is the header for an interface{} value.
 type emptyInterface struct {
     typ  *rtype
     word unsafe.Pointer
 }

 // nonEmptyInterface is the header for a interface value with methods.
 type nonEmptyInterface struct {
     // see ../runtime/iface.go:/Itab
     itab *struct {
         ityp   *rtype // static interface type
         typ    *rtype // dynamic concrete type
         link   unsafe.Pointer
         bad    int32
         unused int32
         fun    [100000]unsafe.Pointer // method table
     }
     word unsafe.Pointer
 }&lt;/pre&gt;&lt;p&gt;コメントに書かれているように実態は &lt;code&gt;runtime/iface.go&lt;/code&gt; ですがこちらのほうが簡略化されていてわかりやすいでしょう。1個目のポインタは 「空のインタフェース( &lt;code&gt;iterface{}&lt;/code&gt; )」(これを &lt;code&gt;eface&lt;/code&gt; という)の場合、型情報、そうでない場合(これを &lt;code&gt;iface&lt;/code&gt; という)の場合 &lt;code&gt;itab&lt;/code&gt; と呼ばれるC&#43;&#43;における仮想テーブルのようなものです。2個目に値が格納されます。2個目はどちらもポインタであることに注意してください。&lt;/p&gt;
&lt;/section&gt;
&lt;section&gt;
&lt;h2&gt;インターフェース経由のメソッド呼び出し&lt;/h2&gt;
&lt;p&gt;ここで、インターフェースを使用するとどの程度パフォーマンスペナルティがあるのか、様々なケースで見てみます。&lt;/p&gt;
&lt;p&gt;まずは、直接メソッドを呼び出すのと、インタフェース経由で呼び出す場合の違いを見てみましょう。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-go&#34;&gt; type MyError struct{}
 func (e *MyError) Error() string { return &#34;error&#34; }

 func BenchmarkNoInterface(b *testing.B) {
     for i := 0; i &amp;lt; b.N; i&#43;&#43; {
         err := &amp;amp;MyError{}
         err.Error()
     }
 }

 func BenchmarkInterface(b *testing.B) {
     for i := 0; i &amp;lt; b.N; i&#43;&#43; {
         var err error = &amp;amp;MyError{}
         err.Error()
     }
 }&lt;/pre&gt;&lt;p&gt;結果は以下のようになります。10倍程度遅くなります。単位が単位なので微々たる違いですが極限までパフォーマンスを追求したい場合は考慮しておいたほうがいいかもしれませんね。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-bash&#34;&gt; BenchmarkNoInterface    2000000000               0.73 ns/op
 BenchmarkInterface      200000000                9.56 ns/op&lt;/pre&gt;&lt;p&gt;しかし実はこの中には &lt;code&gt;*MyError&lt;/code&gt; を &lt;code&gt;error&lt;/code&gt; インタフェースに変換するコストも含まれていて、そのコストを除くと5倍くらいの遅さです。次はそのインタフェースへの変換コストを詳しく見ていこうと思います。&lt;/p&gt;
&lt;/section&gt;
&lt;section&gt;
&lt;h2&gt;インターフェースへの変換コスト(非ポインタ型)&lt;/h2&gt;
&lt;p&gt;Goにおけるインタフェースの変換時はC&#43;&#43;におけるキャストよりも複雑なことが発生します。&lt;/p&gt;
&lt;p&gt;Goでは「なんでも」を表すために &lt;code&gt;interface{}&lt;/code&gt; を使いますね。 &lt;code&gt;int&lt;/code&gt; などの組み込み型かつ非ポインタ型を &lt;code&gt;interface{}&lt;/code&gt; として処理するとなにが起こるでしょうか？以下のようにフィボナッチを計算させてみます。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-go&#34;&gt; func IntFibNoInterface(n int) int {
     if n &amp;lt; 2 {
         return n
     }
     return IntFibNoInterface(n-1) &#43; IntFibNoInterface(n-2)
 }

 func IntFibInterface(o interface{}) interface{} {
     n := o.(int)
     if n &amp;lt; 2 {
         return o
     }
     return IntFibInterface(n-1).(int) &#43; IntFibInterface(n-2).(int)
 }

 func BenchmarkNoInterface(b *testing.B) {
     for i := 0; i &amp;lt; b.N; i&#43;&#43; {
         IntFibNoInterface(20)
     }
 }

 func BenchmarkInterface(b *testing.B) {
     for i := 0; i &amp;lt; b.N; i&#43;&#43; {
         IntFibInterface(20)
     }
 }&lt;/pre&gt;&lt;p&gt;結果は以下。40 - 50倍くらいおそくなりますね。これを見ると気軽にインタフェースを使いたくなくなるかもしれません。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-bash&#34;&gt; BenchmarkNoInterface       30000             57938 ns/op               0 B/op          0 allocs/op
 BenchmarkInterface           500           2448250 ns/op          525376 B/op      32836 allocs/op&lt;/pre&gt;&lt;p&gt;はじめに書いたように、インタフェースは &lt;strong&gt;ポインタとして値を保持します&lt;/strong&gt; 。 そのためコード上アロケートしていなくても、内部的に &lt;code&gt;int&lt;/code&gt; をアロケートしそこに値をコピーせねばなりません。&lt;/p&gt;
&lt;p&gt;どのような処理が実行されたか、プロファイルを見てみましょう。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-bash&#34;&gt; 1.46s of 1.46s total (  100%)
 Showing top 20 nodes out of 35 (cum &amp;gt;= 0.01s)
       flat  flat%   sum%        cum   cum%
      0.37s 25.34% 25.34%      0.68s 46.58%  runtime.mallocgc
      0.26s 17.81% 43.15%      1.44s 98.63%  12.IntFibInterface
      0.20s 13.70% 56.85%      0.20s 13.70%  runtime.memmove
      0.16s 10.96% 67.81%      0.16s 10.96%  runtime.mSpan_Sweep.func1
      0.12s  8.22% 76.03%      0.96s 65.75%  runtime.convT2E
      0.11s  7.53% 83.56%      0.31s 21.23%  runtime.typedmemmove
      0.10s  6.85% 90.41%      0.26s 17.81%  runtime.heapBitsSweepSpan
      0.05s  3.42% 93.84%      0.22s 15.07%  runtime.assertE2T
      0.02s  1.37% 95.21%      0.70s 47.95%  runtime.newobject
      0.02s  1.37% 96.58%      0.02s  1.37%  runtime.prefetchnta
      0.01s  0.68% 97.26%      0.01s  0.68%  runtime.(*gcControllerState).findRunnableGCWorker
      0.01s  0.68% 97.95%      0.01s  0.68%  runtime.lock
      0.01s  0.68% 98.63%      0.01s  0.68%  runtime.mSpanList_InsertBack
      0.01s  0.68% 99.32%      0.01s  0.68%  runtime.xadd64
      0.01s  0.68%   100%      0.01s  0.68%  runtime.xchg
          0     0%   100%      1.44s 98.63%  12.BenchmarkInterface
          0     0%   100%      0.01s  0.68%  runtime.GC
          0     0%   100%      0.01s  0.68%  runtime.deductSweepCredit
          0     0%   100%      0.01s  0.68%  runtime.gc
          0     0%   100%      0.01s  0.68%  runtime.gc.func4&lt;/pre&gt;&lt;/section&gt;
&lt;section&gt;
&lt;h2&gt;非ポインタ型のインターフェースへの変換コスト&lt;/h2&gt;
&lt;p&gt;では、ということで自分でアロケーションしてみましょう。 &lt;code&gt;int&lt;/code&gt; ではなく &lt;code&gt;*int&lt;/code&gt; を使ってみます。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-go&#34;&gt; func IntFibNoInterface(n int) int {
     if n &amp;lt; 2 {
         return n
     }
     return IntFibNoInterface(n-1) &#43; IntFibNoInterface(n-2)
 }

 func IntFibPointer(i *int) *int {
     n := *i
     if n &amp;lt; 2 {
         return i
     }
     a1 := new(int)
     *a1 = n - 1
     a2 := new(int)
     *a2 = n - 2
     v1 := IntFibPointer(a1)
     v2 := IntFibPointer(a2)
     ret := new(int)
     *ret = *v1 &#43; *v2
     return ret
 }

 func IntFibInterface(o interface{}) interface{} {
     n := *(o.(*int))
     if n &amp;lt; 2 {
         return o
     }
     a1 := new(int)
     *a1 = n - 1
     a2 := new(int)
     *a2 = n - 2
     v1 := IntFibInterface(a1).(*int)
     v2 := IntFibInterface(a2).(*int)
     ret := new(int)
     *ret = *v1 &#43; *v2
     return ret
 }

 func BenchmarkNoInterface(b *testing.B) {
     for i := 0; i &amp;lt; b.N; i&#43;&#43; {
         IntFibNoInterface(20)
     }
 }

 func BenchmarkPointer(b *testing.B) {
     for i := 0; i &amp;lt; b.N; i&#43;&#43; {
         a := new(int)
         *a = 20
         IntFibPointer(a)
     }
 }

 func BenchmarkInterface(b *testing.B) {
     for i := 0; i &amp;lt; b.N; i&#43;&#43; {
         a := new(int)
         *a = 20
         IntFibInterface(a)
     }
 }&lt;/pre&gt;&lt;p&gt;結果は以下のようになります。20-30倍というところでしょうか。こちらのほうがコードだけ見ると遅そうですが、なんと &lt;code&gt;int&lt;/code&gt; を使った場合より速いのです。そして、インタフェースへの変換コストは少ない、ということがわかります。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-bash&#34;&gt; BenchmarkNoInterface       30000             55558 ns/op               0 B/op          0 allocs/op
 BenchmarkPointer            1000           1297598 ns/op          525376 B/op      32836 allocs/op
 BenchmarkInterface          1000           1357172 ns/op          525376 B/op      32836 allocs/op&lt;/pre&gt;&lt;pre class=&#34;prettyprint lang-bash&#34;&gt; 1.54s of 1.54s total (  100%)
 Showing top 20 nodes out of 37 (cum &amp;gt;= 0.01s)
       flat  flat%   sum%        cum   cum%
      0.75s 48.70% 48.70%      1.24s 80.52%  runtime.mallocgc
      0.22s 14.29% 62.99%      0.22s 14.29%  runtime.mSpan_Sweep.func1
      0.16s 10.39% 73.38%      0.38s 24.68%  runtime.heapBitsSweepSpan
      0.14s  9.09% 82.47%      1.38s 89.61%  runtime.newobject
      0.11s  7.14% 89.61%      1.49s 96.75%  12.IntFibInterface
      0.08s  5.19% 94.81%      0.08s  5.19%  runtime.prefetchnta
      0.02s  1.30% 96.10%      0.02s  1.30%  runtime.heapBitsForObject
      0.01s  0.65% 96.75%      0.01s  0.65%  runtime.(*bucket).mp
      0.01s  0.65% 97.40%      0.01s  0.65%  runtime.atomicload64
      0.01s  0.65% 98.05%      0.41s 26.62%  runtime.mCentral_CacheSpan
      0.01s  0.65% 98.70%      0.03s  1.95%  runtime.scanblock
      0.01s  0.65% 99.35%      0.01s  0.65%  runtime.schedule
      0.01s  0.65%   100%      0.01s  0.65%  runtime.xchg
          0     0%   100%      1.49s 96.75%  12.BenchmarkInterface
          0     0%   100%      0.04s  2.60%  runtime.backgroundgc
          0     0%   100%      0.01s  0.65%  runtime.deductSweepCredit
          0     0%   100%      0.04s  2.60%  runtime.gc
          0     0%   100%      0.02s  1.30%  runtime.gc.func1
          0     0%   100%      0.01s  0.65%  runtime.gc.func3
          0     0%   100%      0.01s  0.65%  runtime.gc.func4&lt;/pre&gt;&lt;/section&gt;
&lt;section&gt;
&lt;h2&gt;非ポインタ型とポインタ型の違いは？&lt;/h2&gt;
&lt;p&gt;プロファイルをみるとわかりますが、 &lt;code&gt;runtime.convT2E&lt;/code&gt; , &lt;code&gt;runtime.assertE2T&lt;/code&gt; が非ポインタ型の場合重荷になっています。ここまで「ポインタ型」「非ポインタ型」という曖昧な表現をしていましたが、正確には
これは &lt;code&gt;isdirectiface&lt;/code&gt; という関数の結果が &lt;code&gt;true&lt;/code&gt; かどうかです。これによりインターフェス変換の処理が変わります。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-go&#34;&gt; // Can this type be stored directly in an interface word?
 // Yes, if the representation is a single pointer.
 func isdirectiface(t *Type) bool {
     switch t.Etype {
     case TPTR32,
         TPTR64,
         TCHAN,
         TMAP,
         TFUNC,
         TUNSAFEPTR:
         return true

         // Array of 1 direct iface type can be direct.
     case TARRAY:
         return t.Bound == 1 &amp;amp;&amp;amp; isdirectiface(t.Type)

         // Struct with 1 field of direct iface type can be direct.
     case TSTRUCT:
         return t.Type != nil &amp;amp;&amp;amp; t.Type.Down == nil &amp;amp;&amp;amp; isdirectiface(t.Type.Type)
     }

     return false
 }&lt;/pre&gt;&lt;p&gt;これが &lt;code&gt;false&lt;/code&gt; になるオブジェクトをインタフェースとして利用する際は注意です。&lt;/p&gt;
&lt;/section&gt;
&lt;section&gt;
&lt;h2&gt;時にはインタフェースを使わない、という選択も&lt;/h2&gt;
&lt;p&gt;以上のことから、特に性能が必要な場合、インタフェースを使わず擬似共用体(Goに共用体はないので)のような実装をしたほうがよい場合が出てきます。フィボナッチの例を &lt;code&gt;struct&lt;/code&gt; で書いてみましょう。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-go&#34;&gt; const (
     TypeInt int = iota
     TypeBool
 )

 type Object struct {
     Type      int
     IntValue  int
     BoolValue bool
 }

 func IntFibNoInterface(n int) int {
     if n &amp;lt; 2 {
         return n
     }
     return IntFibNoInterface(n-1) &#43; IntFibNoInterface(n-2)
 }

 func IntFibStruct(o Object) Object {
     if o.IntValue &amp;lt; 2 {
         return o
     }
     return Object{TypeInt,
         IntFibStruct(Object{TypeInt, o.IntValue - 1, false}).IntValue &#43;
             IntFibStruct(Object{TypeInt, o.IntValue - 2, false}).IntValue,
         false}
 }

 func BenchmarkNoInterface(b *testing.B) {
     for i := 0; i &amp;lt; b.N; i&#43;&#43; {
         IntFibNoInterface(20)
     }
 }

 func BenchmarkStruct(b *testing.B) {
     for i := 0; i &amp;lt; b.N; i&#43;&#43; {
         IntFibStruct(Object{TypeInt, 20, false})
     }
 }&lt;/pre&gt;&lt;p&gt;速度ですが、インタフェースを使うより断然早く、2-3倍程度しか遅くなりません。当たり前ですが、暗黙的なメモリアロケーションも発生しません。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-bash&#34;&gt; BenchmarkNoInterface       30000             58491 ns/op               0 B/op          0 allocs/op
 BenchmarkStruct            10000            139924 ns/op               0 B/op          0 allocs/op&lt;/pre&gt;&lt;p&gt;&lt;code&gt;reflect&lt;/code&gt; を使えば・・・というのもありますが、結局 &lt;code&gt;reflect.ValueOf&lt;/code&gt; の引数が &lt;code&gt;interface{}&lt;/code&gt; なので素直に使うと &lt;code&gt;interface{}&lt;/code&gt; の場合と同様の遅さです。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-go&#34;&gt; func IntFibNoInterface(n int) int {
     if n &amp;lt; 2 {
         return n
     }
     return IntFibNoInterface(n-1) &#43; IntFibNoInterface(n-2)
 }

 func IntFibReflect(r reflect.Value) reflect.Value {
     n := r.Int()
     if n &amp;lt; 2 {
         return r
     }
     return reflect.ValueOf(IntFibReflect(reflect.ValueOf(n-1)).Int() &#43; IntFibReflect(reflect.ValueOf(n-2)).Int())
 }

 func BenchmarkNoInterface(b *testing.B) {
     for i := 0; i &amp;lt; b.N; i&#43;&#43; {
         IntFibNoInterface(20)
     }
 }

 func BenchmarkReflect(b *testing.B) {
     for i := 0; i &amp;lt; b.N; i&#43;&#43; {
         IntFibReflect(reflect.ValueOf(20))
     }
 }&lt;/pre&gt;&lt;pre class=&#34;prettyprint lang-bash&#34;&gt; BenchmarkNoInterface       30000             56238 ns/op               0 B/op          0 allocs/op
 BenchmarkReflect            1000           2271026 ns/op          525376 B/op      32836 allocs/op&lt;/pre&gt;&lt;/section&gt;
&lt;section&gt;
&lt;h2&gt;ちなみにGopherLuaでは&lt;/h2&gt;
&lt;p&gt;拙作のGo言語によるLua実装 &lt;a class=&#34;reference external&#34; href=&#34;https://github.com/yuin/gopher-lua&#34;&gt;GopherLua&lt;/a&gt; では一番おそい、非ポインタ型をインタフェースとして使う実装になっています。なのでGopherLuaはおそらく現在でもGo上で動くスクリプト言語としては最速の部類ですがさらに速くしようと思えばできたのかもなあと思っています(まぁこの例ほど言語実装は単純ではないし、擬似共用体にするにしてもサイズが大きくなるので、速くなるかどうかはやってみないとなんともいえないのですが。あとサイズがおおきくなるのでスタック型のAPIにするよりないでしょうね)。&lt;/p&gt;
&lt;p&gt;これは使い易さや実装のし易さやメモリ効率、そして「Goらしさ」とのトレードオフだと思っています。私は、とにかく使い易いものがほしかったので一番使い易く、そして実装が楽なものを選びました。&lt;/p&gt;
&lt;p&gt;とはいえ、特に数値型をインタフェースに変換する負荷を軽減するために、独自のアロケータを実装しています。これは一定数の &lt;code&gt;float64&lt;/code&gt; をまとめてアロケートすることでインタフェース変換コストを減らしています。かなり強引なのですが興味のある方は &lt;a class=&#34;reference external&#34; href=&#34;https://github.com/yuin/gopher-lua/blob/master/alloc.go&#34;&gt;gopher-lua/alloc.go&lt;/a&gt; をご参照ください。&lt;/p&gt;
&lt;/section&gt;
&lt;section&gt;
&lt;h2&gt;最後に&lt;/h2&gt;
&lt;p&gt;インタフェースはGoで中心的な役割を果たしていますが、時に大幅なパフォーマンス劣化を起こす可能性があります。 特に、非ポインタ型を &lt;code&gt;interface{}&lt;/code&gt; などとして引数に渡す場合が要注意です。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;reference external&#34; href=&#34;http://qiita.com/advent-calendar/2015/go3&#34;&gt;Go Advent Calendar 2015 その3&lt;/a&gt; 12日目は &lt;a class=&#34;reference external&#34; href=&#34;http://qiita.com/Ladicle&#34;&gt;Ladicle&lt;/a&gt; さんです。&lt;/p&gt;
&lt;/section&gt;
</description>
      
      <category>golang</category>
      
      <guid isPermaLink="true">http://inforno.net/articles/2015/12/11/go-interface-performance-penalty</guid>
      <pubDate>10 Dec 15 15:00 UTC</pubDate>
    </item>
    
    <item>
      <title>icebergのLinux対応版 v0.9.7リリース </title>
      <link>http://inforno.net/articles/2015/11/19/iceberg-0-9-7-released</link>
      <description>&lt;p&gt;コマンドラインランチャー &lt;a class=&#34;reference external&#34; href=&#34;http://yuin.github.io/iceberg/&#34;&gt;iceberg&lt;/a&gt; のv0.9.7 をリリースしました。 GitHubの &lt;a class=&#34;reference external&#34; href=&#34;https://github.com/yuin/iceberg/releases&#34;&gt;リリース一覧&lt;/a&gt; よりダウンロードできます。&lt;/p&gt;
&lt;p&gt;今回からLinuxに対応しました。私は普段、ほぼWindowsがホストでVirtualbox上のUbuntuで開発を行っておりそこではLaunchyを使ってお茶をにごして？いたのです。がやはり慣れているicebergを使いたいと思っていたのでがんばって対応してみました。&lt;/p&gt;
&lt;p&gt;Macを使っている人はそもそもAlfredなどを使っているでしょうけど、Windowsだと私と同じかたちの人も多いのではないかと思います。ぜひ使ってみてください。Linuxのコマンドラインランチャーでmigemo対応しているものはなかなか無いのではないでしょうか。&lt;/p&gt;
&lt;p&gt;icebergはQtやGTKではなくfltkというミニマリストなGUIフレームワークなのでGUI以外の機能はほとんどフレームワークにありません。かといって、ここでQtやGTKに依存するのも癪だったのでLinuxではアイコンのルックアップなどを自分で実装したんですが結構しんどかったですね･･･。ただ、あらかじめマルチプラットフォームを視野にいれたつくりにしてあったので、ゴリゴリ書いていくだけで動くのは動いたのでよかったです。&lt;/p&gt;
&lt;p&gt;内部的にはfltkのバージョンもあげました。これでWindows8以降でも互換モードなしで動いたりしないかなあ、と思っているのですが、いかんせん実機をもっていないのでどうにも。次はWindows10にすると思うので結局Windows8系は確認できないまま終わりそうです。&lt;/p&gt;
&lt;p&gt;あと、ここまできたらなんでMacに対応しないんだ、となりそうですが単純に私がMacを持っていないからです。それに、icebergはMacの文化に合わない気がします。ただ、icebergは作者の私が一番の愛用者であるソフトなのでもし私がMacを手に入れることがあったら、対応すると思います。まぁイケてる会社のプログラマーに転職でもしないとMacを使うようなことはないと思いますが。&lt;/p&gt;
&lt;p&gt;なにか問題ありましたらGithubの &lt;a class=&#34;reference external&#34; href=&#34;https://github.com/yuin/iceberg/issues&#34;&gt;Issues&lt;/a&gt; までどうぞ。&lt;/p&gt;
</description>
      
      <category>iceberg</category>
      
      <guid isPermaLink="true">http://inforno.net/articles/2015/11/19/iceberg-0-9-7-released</guid>
      <pubDate>19 Nov 15 11:58 UTC</pubDate>
    </item>
    
    <item>
      <title>GopherLuaを設定ファイルで使うライブラリを書きました </title>
      <link>http://inforno.net/articles/2015/03/23/gluamapper-released</link>
      <description>&lt;p&gt;&lt;a class=&#34;reference external&#34; href=&#34;https://github.com/yuin/gopher-lua&#34;&gt;GopherLua&lt;/a&gt; で設定ファイルを書くためのライブラリを書きました。設定ファイル以外にも使えますけど。&lt;/p&gt;
&lt;div data-theme=&#34;default&#34; data-height=&#34;150&#34; data-width=&#34;400&#34; data-github=&#34;yuin/gluamapper&#34; class=&#34;github-card&#34;&gt;&lt;/div&gt;&lt;script src=&#34;http://lab.lepture.com/github-cards/widget.js&#34;&gt;&lt;/script&gt;&lt;p&gt;モノとしてはGopherLuaのテーブルをGoの構造体にマップしてくれます。といっても、内部動作的にはHashicorpの &lt;a class=&#34;reference external&#34; href=&#34;https://github.com/mitchellh/mapstructure&#34;&gt;mapstructure&lt;/a&gt; を使っているだけだったりします。一度GopherLuaのテーブルを &lt;code&gt;map[string]interface{}&lt;/code&gt; に変換してあげて、あとはmapstructureにおまかせ。&lt;/p&gt;
&lt;p&gt;ただ、一般的なLuaの命名規則とGoの命名規則が違うので名前を変換する関数が指定できます。デフォルトでは &lt;code&gt;snake_case&lt;/code&gt; を &lt;code&gt;CamelCase&lt;/code&gt; に変換します。&lt;/p&gt;
&lt;pre class=&#34;prettyprint lang-go&#34;&gt; type Role struct {
     Name string
 }

 type Person struct {
     Name      string
     Age       int
     WorkPlace string
     Role      []*Role
 }

 L := lua.NewState()
 if err := L.DoString(`
 person = {
   name = &#34;Michel&#34;,
   age  = &#34;31&#34;, -- weakly input
   work_place = &#34;San Jose&#34;,
   role = {
     {
       name = &#34;Administrator&#34;
     },
     {
       name = &#34;Operator&#34;
     }
   }
 }
 `); err != nil {
     panic(err)
 }
 var person Person
 if err := gluamapper.Map(L.GetGlobal(&#34;person&#34;).(*lua.LTable), &amp;amp;person); err != nil {
     panic(err)
 }
 fmt.Printf(&#34;%s %d&#34;, person.Name, person.Age)&lt;/pre&gt;&lt;p&gt;のように非常に簡単にLuaを設定ファイルとして使うことができます。Luaは可読性が高く、JSONと異なりコメントが書けて、YAMLよりも簡単に値を変数化できるので設定ファイルにすると便利です(なんでも出来てしまう、というのがネックと言えばネックですが)。&lt;/p&gt;
</description>
      
      <category>gopherlua</category>
      
      <category>golang</category>
      
      <category>lua</category>
      
      <guid isPermaLink="true">http://inforno.net/articles/2015/03/23/gluamapper-released</guid>
      <pubDate>23 Mar 15 12:12 UTC</pubDate>
    </item>
    
  </channel>
</rss>
